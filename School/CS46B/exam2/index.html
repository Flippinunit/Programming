<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>CS 46B Exam 2 Spring 2013</title>
<link href="styles.css" rel="stylesheet" type="text/css" />
</head>

<body>
<h1 align="center">EXAM 2</h1>
<h2 align="center">CS 46B Spring 2013</h2>
<h2>Exam Rules</h2>
<ul>
  <li>You may use any books, notes, files. You may only use the Canvas web site.</li>
  <li>It is a good idea to compile and run your programs if you have the time to do it.  I am including some testers.</li>
  <li>You may NOT communicate with anyone during the exam.</li>
  <li>You may NOT use the work of anyone else without attribution.</li>
  <li>You may NOT open any programs or web sites that allow communication with someone else. No messenger, chat, email, discussion forum, etc.</li>
  <li>The proctor will randomly inspect laptops. If your laptop is inspected, you need take the hands off the keyboard immediately.</li>
  <li>Save your solutions into Java source files (extension .java) or plain text files (extension .txt). Be sure to save your work occasionally.</li>
  <li>Submit your solution to Canvas. You may submit as many versions as you likeâ€”the last one will be graded, but <b>submit all completed files
      with each submission.</b>  (If you make one submission with file a.java, and then a second submission with b.java, canvas will only give
      me b.java.  So, for the second submission, submit both a.java and b.java.)</li>
  <li><b>Your code should compile.  Do not use package statements.</b>
    You may not 
    get <b>any</b> credit for any code which does not compile with any
    tester I provide to you.  <b>Save your files before submitting them.</b></li>
</ul>

<p>1. (10 points) Consider the following code for a "Student" class,
  which stores a student, with their name, and their grades.  Also,
  consider the code for the "StudentTester" class.  The runtime of
  the tester depends on the value of variable <b>n</b>.
  <ol class="lower-alpha">
  <li>What is the runtime of the <strong>loop</strong> in StudentTester?
  (The entire loop, not just one iteration.)
Give your answer in big-O notation, as a function of n.  (2 points)
</li>
  <li>What is the runtime of <strong>line 11</strong>?
Give your answer in big-O notation, as a function of n.  (3 points)
</li>
  <li>What is the simplest change you can make to the Student code
to make the Tester run more quickly?  (Tell me the changes in your code, rather than
resubmitting all code.  The fewer changes, the better.) (3 points)</li>
  <li>What will be the new runtimes?  (2 points)</li>
</ol>

<p>Submit your answer to this question separately to the Exam 2,
  question 1 Canvas area.  Either put your answer for this question
  into a text file (.txt extension, no Microsoft Word or rich text
  file), or just cut-and-paste your solution to the problem into
  Canvas.</p>

<pre>import java.util.LinkedList;
import java.util.List;

public class Student {
   private String name;
   private List<Integer> scores = new LinkedList<>();
   
   public Student(String name)
   {
      this.name = name;
   }
   
   public void addGrade(int score)
   {
      scores.add(score);
   }
   
   public String getName()
   {
      return name;
   }
   
   public int getScore(int i)
   {
      return scores.get(i);
   }
   
   public double getAverage()
   {
      if(scores.isEmpty())
         return 0;
      double total = 0;
      for(int i = 0; i < scores.size(); i++)
      {
         total += getScore(i);
      }
      
      return total / scores.size();     
   }
}</pre>

<pre>public class StudentTester {
   public static void main(String[] args)
   {
      int n = 10;
      Student s = new Student("Sam");
      for(int i = 1; i <= n; i++)
      {
         s.addGrade(i);
      }  <strong>//loop</strong>
      
      double average = s.getAverage();   <strong>//line 11</strong>
      
      System.out.println(s.getName() + " " + average);
      System.out.println("Expected: Sam " + (1 + n)/2.0);
   }   
}</pre>

<p>&nbsp;</p>
<p>2. (10 points) Write a "Roster" class which will keep track of some
  students, along with their grades.  The given methods in the code
  below need to work (along with any extra methods they require).
  </p>

<p><strong>Note:</strong>  When I compile your Roster code, I will
  compile it in a directory which contains the Student.java code from
  the previous question.    The given RosterTester should compile and
  run with your code.  If it doesn't compile, as is, with your code,
  you may receive 0 points.
</p>

<pre>
public class Roster {
   
   /**
    * Adds a grade to the end of a list of grades for the named
    student.
    * Should work even if no student with this name has ever been seen
    before.
    * @param name Name of student who is getting the score added.
    * @param score Score being added to student's list of scores.
    */
   public void addGrade(String name, int score)
   
   /**
    * Gets the specified grade from the named student's scores.
    * @param name Name of student whose grade is requested.
    * @param index Index of the grade requested.
    * @return the score requested.
    */
   public int getGrade(String name, int index)
   
   /**
    * Gets the average for the named student.
    * @param name Name of student whose average is requested.
    * @return That students average grade.
    */
   public double getAverage(String name)
}</pre>

<pre>public class RosterTester {
   public static void main(String[] args)
   {
      Roster roster = new Roster();
   
      roster.addGrade("Sam", 7);
      roster.addGrade("Bill", 9);
      roster.addGrade("Sam", 10);
      
      System.out.println(roster.getAverage("Sam"));
      System.out.println("Expected:  8.5");
      System.out.println(roster.getAverage("Bill"));
      System.out.println("Expected:  9.0");
      System.out.println(roster.getGrade("Sam", 0));
      System.out.println("Expected:  7");
      System.out.println(roster.getGrade("Sam", 1));
      System.out.println("Expected:  10");
   }
}</pre>

<p>&nbsp;</p>
<p>3. (10 points)  Consider the following SortedLinkedList
class, which would get most of its functionality from the LinkedList
class it uses.  Complete the add method.  Do not change the included
iterator class.  You should complete the add method, and may add your
own private methods, but should not change any pre-existing methods
(other than completing add).  You should use the given Tester and
Comparator to test your code.  <strong>Your code should compile with these
  testers,</strong> otherwise it may not receive any points.
 <strong>Note:</strong> you may want to
put this into a different project than your other projects, as it uses
java.util.LinkedList and java.util.ListIterator, instead of our own
implementations of them.</p>
<pre>import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

public class SortedLinkedList
{  
   private List list = new LinkedList();
   private Comparator comp;
      
   public SortedLinkedList(Comparator cmp)
   {
      comp = cmp;
   }
   
   /**
      Adds an element in the place it should go, using the comparator.
      This is the method you need to write.  No other given code is incorrect.
   */
   public void add(Object element)
   {  
   }
   
   public Object get(int i)
   {
      return list.get(i);
   }

   public ListIterator listIterator()
   {
      return new SortedListIterator();
   }
  
   class SortedListIterator implements ListIterator
   {
      ListIterator li;
      public SortedListIterator()
      {
         li = list.listIterator();
      }
      
      public boolean hasNext()
      {
         return li.hasNext();
      }
      
      public boolean hasPrevious()
      {
         return li.hasPrevious();
      }
      
      public Object next()
      {
         return li.next();
      }
              
      public Object previous()
      {
         return li.previous();
      }
      
      public int nextIndex()
      {
         return li.nextIndex();
      }

      public int previousIndex() {
         return li.previousIndex();
      }

      @Override
      public void remove() {
         throw new UnsupportedOperationException("Not supported yet.");
      }

      @Override
      public void set(Object e) {
         throw new UnsupportedOperationException("Not supported ever.");
      }

      @Override
      public void add(Object e) {
         throw new UnsupportedOperationException("Not supported ever.");
      }
   }
}</pre>

<pre>public class TestComparator implements Comparator&ltInteger>
{
   public int compare(Integer i1, Integer i2)
   {
      return i2 - i1;  //reverses order, just to spice things up.
   }
}</pre>

<pre>import java.util.ListIterator;

public class SortedLinkedListTester {   
   public static void main(String[] args)
   {
      SortedLinkedList s = new SortedLinkedList(new TestComparator());
      s.add(10);
      s.add(45);
      s.add(5);
      ListIterator li = s.listIterator();
      while(li.hasNext())
         System.out.print(li.next() + " ");
      System.out.println("");
      System.out.println("Expected: 45 10 5");
   }
}</pre>



<p>&nbsp;</p>
<p>4. (10 points)  In a "perfect shuffle" of cards, the deck is cut
  perfectly in half, and then the two halves are exactly alternated
  with each other.  It is a technique favored by magicians, because it
  doesn't really randomize the order of the deck.  Best of all, if the
  shuffle is performed 8 times consecutively, the deck finishes in its
  initial position.  (This assumes a 52 card deck, and that, after
  each shuffle, the top card remains as top card, rather than moving
  to the second card.)</p>

<p>You will write a perfectShuffle() method for our
  LinkedList implementation from class.  My LinkedList implementation
  and ListIterator interface from the Assignment 8 solutions are
  provided.  You may modify the former to add the method, or you may
use your own code if you prefer, but your code must implement the
ListIterator class, and that interface should not be modified.
In writing your shuffle, you should make it so that the
  first item in the list is still the first item after each shuffle.
  However, you should not assume that the list is any specific length
  (nor that it is even), nor should you assume that you are sorting
  strings as given in the Tester example.</p>

<pre>public class ShuffleTester
{
   public static void main(String[] args)
   {
      LinkedList l = new LinkedList();
      for(int i = 1; i <= 10; i++)
      {
         l.addFirst("" + i);
      }  //After this, the list contains 10 9 8 7 6 5 4 3 2 1
      l.perfectShuffle();

      ListIterator li = l.listIterator();
      while(li.hasNext())
      {
        System.out.print(li.next() + " ");
      }
      System.out.println("");
      System.out.println("Expected:  10 5 9 4 8 3 7 2 6 1");
   }
}</pre>

<pre>import java.util.NoSuchElementException;

/**
   A linked list is a sequence of nodes with efficient
   element insertion and removal. This class 
   contains a subset of the methods of the standard
   java.util.LinkedList class.
*/
public class LinkedList
{  
   private Node first;
   private int currentSize;
   
   /** 
      Constructs an empty linked list.
   */
   public LinkedList()
   {  
      first = null;
   }
   
   /**
      Returns the first element in the linked list.
      @return the first element in the linked list
   */
   public Object getFirst()
   {  
      if (first == null) { throw new NoSuchElementException(); }
      return first.data;
   }

   /**
      Removes the first element in the linked list.
      @return the removed element
   */
   public Object removeFirst()
   {  
      if (first == null) { throw new NoSuchElementException(); }
      Object element = first.data;
      first = first.next;
      currentSize--;
      return element;
   }

   /**
      Adds an element to the front of the linked list.
      @param element the element to add
   */
   public void addFirst(Object element)
   {  
      Node newNode = new Node();
      newNode.data = element;
      newNode.next = first;
      first = newNode;
      currentSize++;
   }
   
   /**
      Returns an iterator for iterating through this list.
      @return an iterator for iterating through this list
   */
   public ListIterator listIterator()
   {  
      return new LinkedListIterator();
   }
   
   public LinkedList unzip()
   {
      LinkedList ll = new LinkedList();
      Node node = first;
      if(node == null || node.next == null)
         return ll;
      ll.first = node.next;
      Node newNode = ll.first;
      node.next = node.next.next;
      node = node.next;
      
      while (node != null && node.next != null)
      {
         newNode.next = node.next;
         newNode = node.next;
         node.next = node.next.next;
         node = node.next;
      }

      if(newNode != null)
         newNode.next = null;
      return ll;
   }
   
   public int size1()
   {
      if(first == null) return 0;
      int s = 1;
      Node n = first;
      while (n.next != null)
      {
         s++;
         n = n.next;
      }
      return s;      
   }
   
   public int size2()
   {
      return sizeHelper(first);
   }
   
   private int sizeHelper(Node n)
   {
      if(n == null) return 0;
      return 1 + sizeHelper(n.next);
   }
           
   public int size3()
   {
      return currentSize;
   }
   
   class Node
   {  
      public Object data;
      public Node next;
   }

   class LinkedListIterator implements ListIterator
   {  
      private Node position;
      private Node previous;
      private boolean isAfterNext;

      /**
         Constructs an iterator that points to the front
         of the linked list.
      */
      public LinkedListIterator()
      {  
         position = null;
         previous = null;
         isAfterNext = false;
      }
      
      /**
         Moves the iterator past the next element.
         @return the traversed element
      */
      public Object next()
      {  
         if (!hasNext()) { throw new NoSuchElementException(); }
         previous = position; // Remember for remove
         isAfterNext = true;

         if (position == null)
         {
            position = first;
         }
         else
         {
            position = position.next;
         }

         return position.data;
      }
      
      /**
         Tests if there is an element after the iterator position.
         @return true if there is an element after the iterator position
      */
      public boolean hasNext()
      {  
         if (position == null)
         {
            return first != null;
         }
         else
         {
            return position.next != null;
         }
      }
      
      /**
         Adds an element before the iterator position
         and moves the iterator past the inserted element.
         @param element the element to add
      */
      public void add(Object element)
      {  
         if (position == null)
         {
            addFirst(element);
            position = first;
         }
         else
         {  
            Node newNode = new Node();
            newNode.data = element;
            newNode.next = position.next;
            position.next = newNode;
            position = newNode;
         }
         currentSize++;
         isAfterNext = false;
      }
      
      /**
         Removes the last traversed element. This method may
         only be called after a call to the next() method.
      */
      public void remove()
      {  
         if (!isAfterNext) { throw new IllegalStateException(); }

         if (position == first)
         {
            removeFirst();
         }
         else 
         {  
            previous.next = position.next;
         }
         position = previous;
         currentSize--;
         isAfterNext = false;
      }

      /**
         Sets the last traversed element to a different value. 
         @param element the element to set
      */
      public void set(Object element)
      {
         if (!isAfterNext) { throw new IllegalStateException(); }
         position.data = element;
      }
   }
}
</pre>

<pre>/**
   A list iterator allows access of a position in a linked list.    
   This interface contains a subset of the methods of the 
   standard java.util.ListIterator interface. The methods for
   backward traversal are not included.
*/
public interface ListIterator
{  
   /**
      Moves the iterator past the next element.
      @return the traversed element
   */
   Object next();
      
   /**
      Tests if there is an element after the iterator position.
      @return true if there is an element after the iterator position
   */
   boolean hasNext();
      
   /**
      Adds an element before the iterator position
      and moves the iterator past the inserted element.
      @param element the element to add
   */
   void add(Object element);
      
   /**
      Removes the last traversed element. This method may
      only be called after a call to the next() method.
   */
   void remove();

   /**
      Sets the last traversed element to a different value. 
      @param element the element to set
   */
   void set(Object element);
}</pre>
</body>
</html>
