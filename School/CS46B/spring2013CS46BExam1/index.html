<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>CS 46B Exam 1 Spring 2013</title>
<link href="styles.css" rel="stylesheet" type="text/css" />
<style type="text/css">
<!--
.style1 {
	color: #FF0000;
	font-weight: bold;
}
-->
</style>
</head>

<body>
<h1 align="center">EXAM 1</h1>
<h2 align="center">CS 46B Spring 2013</h2>
<h2>Exam Rules</h2>
<ul>
  <li>You may use any books, notes, files.  You may only use Canvas to download the exam, and upload your solutions.  You cannot use any other websites.</li>
  <li>You may use the Java API.  You should have downloaded it, so it should count as a "file", but even if you didn't, it is the one website you may use for the first exam.</li> 
  <li>It is a good idea to compile and run your programs if you have the time to do it.  <b>However, be warned:  the exam is long.</b>  To balance that out, it is also difficult.</li>
  <li>You may NOT communicate with anyone during the exam.</li>
  <li>You may NOT use the work of anyone else without attribution.</li>
  <li>You may NOT open any programs or web sites that allow communication with someone else. No messenger, chat, email, discussion forum, etc.</li>
  <li>The proctor will randomly inspect laptops. If your laptop is inspected, you need take the hands off the keyboard immediately.</li>
  <li>Save your solutions into Java source files (extension .java) or plain text files (extension .txt). Be sure to save your work occasionally.</li>
  <li>Submit your solution to Canvas. You may submit as many versions as you likeâ€”the last one will be graded.</li>
  <li>Submit the answers to your 2nd and 3rd problems (.txt files) seperately to Canvas.  (There is a separate place to submit each.)  All java file submissions should be made to "Exam 1" in Canvas.</li>
</ul>

<ol>
<li><p>(10 points) Look at the partial Assignment class below.  Complete the class 
<b>so that the grade can never be set negative, nor above the maximum score: 
if setGrade method is given an illegal grade, throw an IllegalArgumentException.</b> 
Otherwise set the grade.  Upload the .java file</p>
<pre>
/**
 * The assignment class keeps one score for one student, as well as the
 * perfect score.  Student scores should default to 0 if they are requested
 * before being set.
 * @author you
 */
public class Assignment
{
     //any fantastic code you want here.

     /**
     * Creates the assignment, setting the perfect mark.
     * @param perfectScore This student's mark
     */
    public Assignment(int perfectScore)
    {
     //any fantastic code you want here.
    }
   
    /**
     * Sets the score for this student.
     * @param score This student's mark
     */
    public void setScore(int score)
    {
     //any fantastic code you want here.
    } 
    
     /**
     * Gets the score for this student.
     */
    public int getScore()
    {
     //any fantastic code you want here.
    }

     /**
     * Gets the grade for this student, normalized to 0.0-100.0 range.
     */
    public double getGradeAsPercentage()
    {
     //any fantastic code you want here.
    } 
}</pre>
</li>
<li><p>(9 points) Here are a Countable interface, and AbstractFiniteSet and University classes.</p>

<pre>public interface Countable
{
   boolean isInfinite();
   int number(); 
}</pre>

<pre>public abstract class AbstractFiniteSet implements Countable
{
    public final boolean isInfinite()
    {
       return false;
    }
}
</pre>
<pre>
public class University extends AbstractFiniteSet
{
   private int students;

   public University(int size)
   {
      students = size;
   }

   public int number()
   {
      return students;
   }
}</pre>

<ol class="lower-alpha">
<li>If you remove the word "abstract" (the all-lowercase one) from the AbstractFiniteSet case, why won't the code compile without error?  Give a short answer.  (2 points)</li>
<li>Starting with the given files, is the following line legal?
(That is, will it give a syntax error?)  <span class="style1">Why or why not?</span> 
(Assume the given line is in a proper method somewhere.) (2 points) 
<pre>Countable c = new University(30438);</pre>
</li>
<li>What does the "final" keyword do in the AbstractFiniteSet class?  Why was it included in this class? (3 points)</li>
<li>Stylistically, why is it bad that University extends the AbstractFiniteSet class?  (2 points)</li>
</ol>
<p>Put your answers in a text document
  called <strong>problem2.txt.</strong> (no word
  files).  <strong>Upload it separately to the Exam 1, problem 2 assignment.</strong></p>

</li>


<li><p>(6 points)  While playing with the BankAccount class during
    class, I did some experiments regarding overriding and
    polymorphism.  Consider the following code, similar to what we had
    during those experiments.  (The SavingsAccount code given here 
    matches the code from the textbook, with the last three methods added.)</p>
<pre>/**
   An account that earns interest at a fixed rate.
*/
public class SavingsAccount extends BankAccount
{  
   private double interestRate;

   /**
      Constructs a bank account with a given interest rate.
      @param rate the interest rate
   */
   public SavingsAccount(double rate) 
   {  
      interestRate = rate;
   }

   /**
      Adds the earned interest to the account balance.
   */
   public void addInterest() 
   {  
      double interest = getBalance() * interestRate / 100;
      deposit(interest); 
   }


   public static void main(String[] args)
   {
      BankAccount ba = new SavingsAccount(2.5);
      SavingsAccount sa = new SavingsAccount(3.0);
      ba.testMethod(sa);
   }

   public void testMethod(BankAccount a)
   {
      System.out.println("Output 1");
   }

   public void testMethod(SavingsAccount a)
   {
      System.out.println("Output 2");
   }
}</pre>

<p>Three different students use this class, exactly as written, and add it to the same directory as their (already written) BankAccount class.
But, when they each try to run the main method of SavingsAccount, they get different results:
<ol><li>Student 1 gets "Output 1" to print.</li>
<li>Student 2 gets "Output 2" to print.</li>
<li>Student 3 gets an error when he tries to compile.</li></ol>
Explain why they would get these results, as caused by overriding and polymorphism reasons.  (2 points each.)
Put your answers in a text document
called <strong>problem3.txt.</strong> (no word files).  
<strong>Upload it separately to the Exam 1, problem 3 assignment.</strong></p>
</li>

<li><p>(10 points)  Write a class SillyStringComparator that
    implements the Comparator interface and provide the required
    compare () method. The compare() method compares strings
    normally, <i>except starting with the 2nd character instead of the
      1st, appending the first letter to the end.</i>  So, "cat"
    would be smaller than "ace", because "atc" comes alphabetically
    before "cea".  And, "terrific" would be smaller than "awful",
    because "errifict" comes before "wfula".  The empty string should
    not crash your code:  treat it as the "biggest" string.  Submit
    SillyStringComparator.java</p></li>  


<li><p>(10 points) Given two Strings, you will try to find the length of a longest string that is found within both given Strings.  For example, 
in the strings "abcdef" and "abracadabra", the string "abcd" is found within each string (with indices 0, 1, 2, 3 in the first string, and indices
0, 1, 4, 6 in the second), and you should return the int 4 as your solution.  Notice that the characters of the string found do not need to be
consecutively ordered in the original strings, but they must be in order.</p>

<p>There is a simple recursive solution to solve this problem, and it looks a lot like the solution to homework assignment 4c.  (It also has some similarities to 4b.)  I include a solution
to 4c below.  Your answer should use recursion.  I would also highly recommend that you use the answer to homework 4c as a model.  Hint:  if the first characters of the strings match, recursively solve the rest of the problem.  If the first characters don't match, make one string shorter, and recursively solve the problem.  Which string to make shorter?  Recursively try both, and use whichever worked better.</p>

<pre>public class Hw4c {
    public static boolean everyDayImShuffling(String a, String b, String c)
    {
        return everyDayImShuffling(a, 0, b, 0, c);
    }
    
    private static boolean everyDayImShuffling(String a, int aIndex, 
            String b, int bIndex, String c)
    {
        if(a.length() == aIndex)  //String a is empty
            return b.substring(bIndex).equals(c.substring(bIndex+aIndex));
        if(b.length() == bIndex)  //String b is empty
            return a.substring(aIndex).equals(c.substring(bIndex+aIndex));
        
        if(a.charAt(aIndex) == c.charAt(aIndex + bIndex) &&
                everyDayImShuffling(a, aIndex+1, b, bIndex, c))
            return true;
        return(b.charAt(bIndex) == c.charAt(aIndex + bIndex) &&
                everyDayImShuffling(a, aIndex, b, bIndex+1, c));
    }
}</pre>

<p>Submit a solution in file named Test1Q5, with a static method named maxLengthSharedString.  I have started the file for you below, and included a Tester in main.</p>
<pre>public class Test1Q5 {
    public static void main(String[] args)
    {
       String a = "abcdef";
       String b = "abracadabra";
       System.out.println("Length:  " + maxLengthSharedString(a, b));
       System.out.println("Expected:  4");
    }

    public static int maxLengthSharedString(String a, String b)
    {
       //Fantastically great code here.  You might want a helper function too.
    }
}</pre></li>

<li><p>(10 points) Complete the class below to read a file of baby names in the same format as this file, <a href="smallNames.txt">smallNames.txt</a>, but your program should work with any file name.  Given a filename, "male" or "female", and a percentage, 
your code should print the fewest number of boys or girls names required to surpass the given percentage.  In each call to your program, you will only report on one of the two sexes.  
Get the file name from the command line. If the file name is not present, print:</p>
<p>   File not found:  (Name of file)</p>
<p>Print the statement with the filename in place of (Name of file), and with exactly 2 spaces after the ":".  <b>You do not need to worry about bad file formats, or other errors in usage not requested.</b>  I won't, for instance, call your code with "male" mispelled, so save your time.  You may also assume that the file will have more than enough names for any number I request.</p>

<p>This will require a try/catch block.</p>
<pre>public class FewestBabyNamesNeeded
{
    public static void main(String[] args)
    {
        if (args.length != 3)
        {
           System.out.println("Usage: java FewestBabyNamesNeeded filename male value");
           System.out.println("or: java FewestBabyNamesNeeded filename female value");
        }
        else
        {
           String filename = args[0];
           //..your code goes here
        }
    }

}</pre>
<p>The file format follows.  Each line in the file contains seven entries:</p>
<ul>
  <li>The rank (from 1 to 1,000)</li>
  <li>The name, <strong>frequency</strong>, and percentage of the male name of that rank</li>
  <li>The name, <strong>frequency</strong>, and percentage of the female name of that rank</li>
</ul>
<pre>1  Michael  462085  2.2506  Jessica  302962  1.5436
2  Christopher  361250  1.7595  Ashley  301702  1.5372
3  Matthew  351477  1.7119  Emily  237133  1.2082
4  Joshua  328955  1.6022  Sarah  224000  1.1413
5  Jacob  298016  1.4515  Samantha  223913  1.1408
6  Nicholas  275222  1.3405  Amanda  190901  0.9726
7  Andrew  272600  1.3277  Brittany  190779  0.9720
8  Daniel  271734  1.3235  Elizabeth  172383  0.8783
9  Tyler  262218  1.2771  Taylor  168977  0.8609
10  Joseph  260365  1.2681  Megan  160312  0.8168
11  Brandon  259299  1.2629  Hannah  158647  0.8083
12  David  253193  1.2332  Kayla  155844  0.7940
13  James  244775  1.1922  Lauren  153530  0.7822
14  Ryan  241105  1.1743  Stephanie  149725  0.7628
15  John  239730  1.1676  Rachel  148907  0.7587
16  Zachary  225188  1.0968  Jennifer  147948  0.7538
17  Justin  220012  1.0716  Nicole  136033  0.6931
18  William  217588  1.0598  Alexis  131117  0.6680
19  Anthony  216088  1.0525  Victoria  117386  0.5981
20  Robert  205313  1.0000  Amber  115551  0.5887</pre>

<p>"java FewestBabyNamesNeeded smallNames.txt male 5" should print, simply, the number 3, because 3 male names (Michael, Christopher, and Matthew)
are needed to surpass 5% of all male names.  "java FewestBabyNamesNeeded smallNames.txt female 5" should print the number 4, because 3 female names (Jessica, 
Ashley, Emily, Sarah) are required.  Upload your FewestBabyNamesNeeded.java file.</p></li>
</body>
</html>
