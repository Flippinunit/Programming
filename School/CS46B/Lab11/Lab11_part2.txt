                             Anthony Langga (Driver)/ Alvyn Ly (Scribe)

E1) Done
E2) Done
E3) Done
E4)
                      
  t.root = new BinarySearchTree.Node();
           
E5) t.root.data = n;
E6)    public BinarySearchTree copy() {
      BinarySearchTree poop = new BinarySearchTree();
      poop.root = copy(this.root);
      return poop;
      
   }
   public Node copy(Node n) {
      if (n == null ) {
         return null;
         
      } else {
         Node newRoot = new Node();
         newRoot.data = n.data;
         newRoot.left = copy(n.left);
         newRoot.right= copy(n.right);
         return newRoot;
      }
   }
 
E7) Done

E8) Done

E9) Done

F1) Done

F2) 
   public void testRemove(int n) {
      List<BinarySearchTree> taco = Trees4.allTrees(n);
      for (BinarySearchTree poop : taco) {
         Trees4.fill(poop.root, n);
         for (int i = 0; i < n; i++) {
            BinarySearchTree bbq = poop.copy();
            bbq.remove(i + 1);
            assertFalse(bbq.find(i + 1));
         }
      }
   }
F3) It errors

F4) It errors again

F5) It passed

F6)It still passes

G1) Done

G2) Done

G3 

      if (smallestParent == toBeRemoved) {
         smallestParent.left = smallest.left;
      } else {
         smallestParent.right = smallest.left;
      }

 subtree

      Node smallestParent = toBeRemoved;
      Node smallest = toBeRemoved.left;
      while (smallest.right != null) {
         smallestParent = smallest;
         smallest = smallest.right;

G4) DOne

G5) Done
